<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Backpfeifen Simulator — Multiplayer</title>
<style>
  :root{--bg:#0f0f12;--card:#15151a;--accent:#d97706;--muted:#9aa0a6}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:#e6e6e6;background:linear-gradient(180deg,#0b0b0d 0%, #0f1013 100%);}
  .wrap{min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:20px}
  .card{width:100%;max-width:1100px;background:rgba(255,255,255,0.02);border-radius:14px;padding:18px;box-shadow:0 6px 30px rgba(0,0,0,0.6);display:grid;grid-template-columns:1fr 360px;gap:18px}
  header{display:flex;align-items:center;gap:12px}
  h1{margin:0;font-size:20px;letter-spacing:0.6px}
  canvas{width:100%;height:560px;border-radius:10px;background:linear-gradient(180deg,#0b0b0d,#121217);display:block}
  .sidebar{padding:10px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:10px}
  .stat{display:flex;justify-content:space-between;padding:8px 6px;border-radius:8px;background:rgba(0,0,0,0.15);margin-bottom:8px}
  .btn{display:inline-block;padding:10px 12px;border-radius:10px;background:var(--accent);color:#0b0b0d;font-weight:600;cursor:pointer;text-align:center}
  .muted{color:var(--muted);font-size:13px}
  label{display:block;font-size:13px;margin:8px 0 6px}
  input[type=range]{width:100%}
  textarea{width:100%;height:80px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:6px;border-radius:6px}
  .small{font-size:12px;color:var(--muted)}
  footer{grid-column:1/-1;margin-top:12px;text-align:center;color:var(--muted);font-size:13px}
  @media (max-width:900px){.card{grid-template-columns:1fr;}.sidebar{order:2}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div>
      <header>
        <div>
          <h1>Backpfeifen Simulator — Multiplayer</h1>
          <div class="muted">Online-Peer-to-Peer (kein Server nötig) — Signalisierung per Kopieren/Einfügen.</div>
        </div>
      </header>

      <canvas id="game" width="1200" height="760" role="img" aria-label="Backpfeifen Simulator Spielfeld"></canvas>
      <footer>Benutze die Multiplayer-Box rechts: Erstelle ein Angebot, sende es an die andere Person, lasse dir die Antwort geben und füge sie hier ein.</footer>
    </div>

    <aside class="sidebar">
      <div class="stat"><div>Score (du)</div><div id="score">0</div></div>
      <div class="stat"><div>Score (gegner)</div><div id="scoreRemote">0</div></div>
      <div class="stat"><div>Combo</div><div id="combo">0</div></div>
      <div class="stat"><div>Power</div><div id="power">0</div></div>

      <label for="sensitivity">Empfindlichkeit</label>
      <input id="sensitivity" type="range" min="0.4" max="2.0" step="0.05" value="1.0">

      <label for="slowmo">Zeitlupe</label>
      <input id="slowmo" type="range" min="0" max="1" step="0.01" value="0">

      <div style="height:8px"></div>

      <div class="muted">Multiplayer (P2P)</div>
      <div style="display:flex;gap:8px;margin:6px 0 12px"><div class="btn" id="createOffer">Angebot erstellen</div><div class="btn" id="createAnswer">Antwort einfügen</div></div>
      <textarea id="signalOut" placeholder="Hier erscheint das Angebot (kopieren & senden)"></textarea>
      <div style="height:6px"></div>
      <textarea id="signalIn" placeholder="Füge das Angebot/Antwort hier ein und klicke 'Antwort einfügen'"></textarea>
      <div style="height:8px"></div>
      <div class="muted small">Status: <span id="connStatus">offline</span></div>

      <div style="height:10px"></div>
      <div class="btn" id="reset">Zurücksetzen</div>

      <div style="height:10px"></div>
      <div class="muted">Hinweis:</div>
      <div class="small muted">Dieses Multiplayer-System verwendet WebRTC DataChannels. Du brauchst keinen Server, aber ein sicheres Mittel, um Signalisierungs-Nachrichten (Angebot/Antwort) zwischen Spielern zu tauschen (Chat, Messenger, QR-Code usw.).</div>
    </aside>
  </div>
</div>

<script>
// --- Basis-Spiel (fast unverändert) ---
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let w = canvas.width, h = canvas.height;

  // Game state
  let score = 0, scoreRemote = 0, combo = 0, power = 0;
  const scoreEl = document.getElementById('score');
  const scoreRemoteEl = document.getElementById('scoreRemote');
  const comboEl = document.getElementById('combo');
  const powerEl = document.getElementById('power');
  const sensitivityEl = document.getElementById('sensitivity');
  const slowmoEl = document.getElementById('slowmo');
  const connStatusEl = document.getElementById('connStatus');

  // Character
  const head = {x: w*0.6, y: h*0.45, r: 120, rot:0, vx:0, vy:0};
  const particles = [];

  // Input
  let dragging = false, dragStart = null, dragEnd = null;

  function rand(a,b){return a + Math.random()*(b-a)}
  function addParticles(x,y,n,baseV){ for(let i=0;i<n;i++) particles.push({x,y,vx:rand(-baseV,baseV),vy:rand(-baseV,baseV),life:rand(0.4,1.2),t:0,size:rand(3,8)}); }

  // Audio
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playSlap(intensity){
    const dur = 0.06 + Math.min(intensity,1)*0.18;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const noise = audioCtx.createBufferSource();
    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
    noise.buffer = buffer;
    osc.type = 'square'; osc.frequency.value = 500 + 1500 * intensity; gain.gain.value = 0.0001;
    osc.connect(gain); noise.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.5 * intensity + 0.1, now + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.001, now + dur);
    osc.start(now); osc.stop(now + dur); noise.start(now); noise.stop(now + dur);
  }

  function applySlap(vx,vy,fromRemote=false){
    const intensity = Math.min(Math.sqrt(vx*vx+vy*vy)/40, 1.8) * Number(sensitivityEl.value);
    power = Math.round(intensity*100);
    powerEl.textContent = power;

    head.vx += vx*0.06*intensity;
    head.vy += vy*0.02*intensity;
    head.rot += vx*0.00075*intensity;

    const gained = Math.round(10 + 60*intensity + Math.floor(combo)*2);
    if(fromRemote) { scoreRemote += gained; } else { score += gained; }
    if(!fromRemote) combo = Math.min(combo+1, 99);

    addParticles(head.x + head.r*Math.cos(head.rot), head.y + 20, 12 + Math.round(20*intensity), 6 + 18*intensity);
    try{ playSlap(Math.min(intensity/1.3,1)); }catch(e){}
    updateUI();
  }

  function updateUI(){ scoreEl.textContent = score; scoreRemoteEl.textContent = scoreRemote; comboEl.textContent = Math.floor(combo); powerEl.textContent = power; }

  // Input handlers
  function startDrag(e){ e.preventDefault(); dragging = true; dragStart = getPos(e); dragEnd = dragStart; }
  function moveDrag(e){ if(!dragging) return; dragEnd = getPos(e); }
  function endDrag(e){ if(!dragging) return; dragging=false; const p = dragStart, q = dragEnd || getPos(e); const dx = q.x - p.x, dy = q.y - p.y; const strength = Math.hypot(dx,dy); if(strength > 18){ applySlap(dx,dy,false); sendPeer({type:'slap',dx,dy}); } else { applySlap(dx*0.5,dy*0.5,false); sendPeer({type:'slap',dx:dx*0.5,dy:dy*0.5}); } dragStart = dragEnd = null; }
  function getPos(e){ if(e.touches && e.touches[0]) e = e.touches[0]; const rect = canvas.getBoundingClientRect(); const x = (e.clientX - rect.left) * (canvas.width / rect.width); const y = (e.clientY - rect.top) * (canvas.height / rect.height); return {x,y}; }

  canvas.addEventListener('mousedown', startDrag); window.addEventListener('mousemove', moveDrag); window.addEventListener('mouseup', endDrag);
  canvas.addEventListener('touchstart', startDrag, {passive:false}); window.addEventListener('touchmove', moveDrag, {passive:false}); window.addEventListener('touchend', endDrag);

  document.getElementById('reset').addEventListener('click', ()=>{ score=0; scoreRemote=0; combo=0; power=0; head.vx=head.vy=head.rot=0; particles.length=0; updateUI(); sendPeer({type:'reset'}); });

  // --- Multiplayer: simple manual WebRTC signaling ---
  let pc = null, dc = null;
  const signalOut = document.getElementById('signalOut');
  const signalIn = document.getElementById('signalIn');
  const createOfferBtn = document.getElementById('createOffer');
  const createAnswerBtn = document.getElementById('createAnswer');

  function setStatus(s){ connStatusEl.textContent = s; }

  function setupPeerConnection(isOffer){
    pc = new RTCPeerConnection({iceServers:[{urls:['stun:stun.l.google.com:19302']} ]});
    pc.onicecandidate = e => { if(e.candidate) return; /* wait for complete local description */ };
    pc.onconnectionstatechange = () => { setStatus(pc.connectionState); };
    pc.ondatachannel = ev => { dc = ev.channel; wireDataChannel(); };

    if(isOffer){
      dc = pc.createDataChannel('game');
      wireDataChannel();
    }
  }

  function wireDataChannel(){
    if(!dc) return;
    dc.onopen = () => { setStatus('verbunden'); console.log('DataChannel offen'); };
    dc.onclose = () => { setStatus('geschlossen'); };
    dc.onerror = e => { console.warn('DC error', e); };
    dc.onmessage = e => { try{ const msg = JSON.parse(e.data); handlePeerMessage(msg); }catch(err){ console.warn('msg parse', err); } };
  }

  async function createOffer(){
    setupPeerConnection(true);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    // wait for ICE gathering to complete
    await waitForIceGatheringComplete(pc);
    signalOut.value = JSON.stringify(pc.localDescription);
    setStatus('Angebot erstellt — sende es an Spieler B');
  }

  async function createAnswer(){
    const txt = signalIn.value.trim(); if(!txt) return alert('Füge zuerst Angebot/Antwort ein');
    const data = JSON.parse(txt);
    if(data.type === 'offer'){
      setupPeerConnection(false);
      await pc.setRemoteDescription(data);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await waitForIceGatheringComplete(pc);
      signalOut.value = JSON.stringify(pc.localDescription);
      setStatus('Antwort erstellt — sende sie an Spieler A');
    } else if(data.type === 'answer'){
      if(!pc) return alert('Kein lokales Angebot erstellt. Erstelle zuerst ein Angebot.');
      await pc.setRemoteDescription(data);
      setStatus('Antwort empfangen — Verbindung stellt sich her');
    } else {
      alert('Unerwartete Signalisierungs-Nachricht');
    }
  }

  function waitForIceGatheringComplete(pc){
    return new Promise(resolve => {
      if(pc.iceGatheringState === 'complete') resolve();
      function check(){ if(pc.iceGatheringState === 'complete'){ pc.removeEventListener('icegatheringstatechange', check); resolve(); } }
      pc.addEventListener('icegatheringstatechange', check);
      // timeout fallback
      setTimeout(resolve, 3000);
    });
  }

  function sendPeer(obj){ if(dc && dc.readyState === 'open'){ try{ dc.send(JSON.stringify(obj)); }catch(e){ console.warn('send failed', e); } } }

  function handlePeerMessage(msg){
    if(!msg || !msg.type) return;
    if(msg.type === 'slap'){
      // remote slapped — apply a local visual reaction and add to remote score
      applySlap(msg.dx, msg.dy, true);
    } else if(msg.type === 'reset'){
      scoreRemote = 0; score = 0; combo = 0; updateUI();
    }
  }

  createOfferBtn.addEventListener('click', async ()=>{ signalOut.value=''; await createOffer(); });
  createAnswerBtn.addEventListener('click', async ()=>{ await createAnswer(); });

  // allow pasting an answer when you're the offer-creator
  document.getElementById('signalIn').addEventListener('paste', async (e)=>{
    // small UX: try auto-applying if it looks like an answer
    setTimeout(async ()=>{
      const txt = signalIn.value.trim(); if(!txt) return;
      try{ const data = JSON.parse(txt); if(data.type === 'answer' && pc){ await pc.setRemoteDescription(data); setStatus('Antwort empfangen — Verbindung stellt sich her'); } }
      catch(e){}
    },50);
  });

  // --- Rendering & loop ---
  let last = performance.now();
  function loop(t){
    const dtRaw = (t - last) / 1000; last = t;
    const slow = 1 - Number(slowmoEl.value);
    const dt = dtRaw * (0.5 + 0.5*slow);

    head.vx *= Math.pow(0.98, dt*60);
    head.vy = head.vy*0.98 + 650*dt*0.001;
    head.x += head.vx * 60 * dt;
    head.y += head.vy * 60 * dt;
    head.rot *= Math.pow(0.94, dt*60);
    head.x += (w*0.6 - head.x) * (0.02*dt*60);
    head.y += (h*0.45 - head.y) * (0.02*dt*60);

    for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.t += dt; p.x += p.vx * 60 * dt; p.y += p.vy * 60 * dt; p.vy += 40 * dt; if(p.t > p.life) particles.splice(i,1); }
    combo = Math.max(0, combo - dt*0.8); combo = Math.floor(combo);
    render(); requestAnimationFrame(loop);
  }

  function render(){ ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.globalAlpha = 0.06; for(let x=0;x<canvas.width;x+=60){ ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(x,0,1,canvas.height); } for(let y=0;y<canvas.height;y+=60){ ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(0,y,canvas.width,1); } ctx.restore();
    ctx.save(); ctx.translate(head.x, head.y); ctx.rotate(head.rot);
    ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.fillRect(-60, head.r+20, 120, 36);
    const g = ctx.createRadialGradient(-40,-40,20,0,0,head.r*1.2); g.addColorStop(0,'#fff'); g.addColorStop(0.12,'#f8f2ec'); g.addColorStop(0.6,'#e7d8c6'); g.addColorStop(1,'#bfa58f'); ctx.beginPath(); ctx.arc(0,0,head.r,0,Math.PI*2); ctx.fillStyle = g; ctx.fill();
    const eyeClose = Math.min(1, Math.abs(head.vx)*0.02 + Math.abs(head.vy)*0.01);
    ctx.fillStyle = '#3b3b3b'; ctx.beginPath(); ctx.ellipse(-40, -18, 18, 10 - 8*eyeClose, 0, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(40, -18, 18, 10 - 8*eyeClose, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#b5836b'; ctx.beginPath(); ctx.ellipse(0, 6, 16, 22, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = head.vx>6 ? '#202020' : '#402b22'; ctx.beginPath(); ctx.ellipse(0, 60, 44, 24, 0, 0, Math.PI); ctx.fill();
    const blush = Math.min(1, Math.abs(head.vx)*0.015 + Math.abs(head.vy)*0.01); if(blush>0){ ctx.fillStyle = `rgba(220,80,80,${Math.min(0.5,blush)})`; ctx.beginPath(); ctx.ellipse(-58,20,34,22,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(58,20,34,22,0,0,Math.PI*2); ctx.fill(); }
    ctx.fillStyle='#25180f'; ctx.beginPath(); ctx.ellipse(0,-110,140,80,0,0,Math.PI*2); ctx.fill(); ctx.restore();
    if(dragging && dragStart && dragEnd){ ctx.save(); ctx.lineWidth=6; ctx.lineCap='round'; ctx.strokeStyle='rgba(215,120,6,0.9)'; ctx.beginPath(); ctx.moveTo(dragStart.x, dragStart.y); ctx.lineTo(dragEnd.x, dragEnd.y); ctx.stroke(); ctx.restore(); }
    for(const p of particles){ ctx.globalAlpha = Math.max(0,1 - p.t/p.life); ctx.beginPath(); ctx.arc(p.x, p.y, p.size,0,Math.PI*2); ctx.fillStyle = 'rgba(255,200,130,0.95)'; ctx.fill(); }
    ctx.globalAlpha = 1; ctx.save(); ctx.font='20px Inter, system-ui'; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText('Score: ' + score, 22, 34); ctx.fillText('Gegner: ' + scoreRemote, 22, 62); ctx.restore();
  }

  updateUI(); requestAnimationFrame(loop);
  ['mousedown','touchstart'].forEach(evt => window.addEventListener(evt, ()=>{ if(audioCtx.state === 'suspended') audioCtx.resume(); }, {once:true}));

})();
</script>
</body>
</html>
